<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quiz de HCN para la inteligencia artificial</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 24px; }
    .app { max-width: 980px; margin: 0 auto; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 14px; padding: 18px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .between { justify-content: space-between; }
    .muted { opacity: .75; }
    .badge {
      display: inline-flex; align-items: center; gap: 8px;
      border: 1px solid rgba(127,127,127,.35);
      padding: 4px 10px; border-radius: 999px;
      font-size: 12px; font-weight: 650;
    }
    h1 { margin: 0 0 10px; font-size: 22px; }
    h2 { margin: 0 0 10px; font-size: 18px; }
    p { margin: 10px 0; line-height: 1.45; }
    .opts { margin-top: 12px; display: grid; gap: 10px; }
    label.opt {
      display: flex; gap: 10px; align-items: flex-start;
      padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(127,127,127,.35);
      cursor: pointer;
    }
    label.opt:hover { background: rgba(127,127,127,.10); }
    input[type="radio"] { margin-top: 3px; }
    .btns { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.12);
      padding: 10px 12px; border-radius: 12px;
      cursor: pointer; font-weight: 700;
    }
    button.primary { background: rgba(0, 140, 255, .18); }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .feedback {
      margin-top: 14px;
      padding: 12px; border-radius: 12px;
      border: 1px solid rgba(127,127,127,.35);
    }
    .ok { border-color: rgba(0, 200, 80, .55); }
    .bad { border-color: rgba(255, 80, 80, .55); }
    .small { font-size: 13px; }
    .divider { height: 1px; background: rgba(127,127,127,.35); margin: 16px 0; }
    .review-item { padding: 12px 0; border-bottom: 1px dashed rgba(127,127,127,.35); }
    .review-item:last-child { border-bottom: none; }
    code { padding: 2px 6px; border-radius: 8px; background: rgba(127,127,127,.15); }
    .controls { display: grid; gap: 12px; margin-top: 10px; }
    .panel { padding: 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); }
    select { padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); background: transparent; }
    .inline { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 700px) { .grid2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
<div class="app">
  <div class="card" id="screen"></div>
</div>

<script>
/* =========================
   TTS (Text-to-Speech) navegador
   - Sin servicios externos
   - Compat: Chrome/Edge/Android, Safari iOS/macOS, etc.
========================= */
let _ttsVoices = [];
let _ttsWarned = false;

function ttsSupported() {
  return typeof window !== 'undefined' && 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
}

function ttsLoadVoices() {
  if (!ttsSupported()) return;
  _ttsVoices = window.speechSynthesis.getVoices() || [];
}

// Carga voces (algunos navegadores lo hacen async)
if (ttsSupported()) {
  ttsLoadVoices();
  window.speechSynthesis.onvoiceschanged = ttsLoadVoices;
}

function ttsPickSpanishVoice() {
  const v = _ttsVoices || [];
  return (
    v.find(x => (x.lang || '').toLowerCase() === 'es-es') ||
    v.find(x => (x.lang || '').toLowerCase().startsWith('es')) ||
    null
  );
}

function ttsStop() {
  if (ttsSupported()) window.speechSynthesis.cancel();
}

function ttsSpeak(text) {
  if (!ttsSupported()) {
    if (!_ttsWarned) {
      _ttsWarned = true;
      alert('Este navegador no soporta lectura en voz alta (Text-to-Speech).');
    }
    return;
  }

  const t = String(text || '').trim();
  if (!t) return;

  // Asegura voces (por si a√∫n no estaban)
  ttsLoadVoices();

  // Para cualquier locuci√≥n previa
  window.speechSynthesis.cancel();

  const u = new SpeechSynthesisUtterance(t);
  u.lang = 'es-ES';

  const voice = ttsPickSpanishVoice();
  if (voice) u.voice = voice;

  u.rate = 1;
  u.pitch = 1;
  u.volume = 1;

  // Algunos navegadores necesitan un "tick" tras cancel()
  setTimeout(() => {
    try { window.speechSynthesis.speak(u); } catch (e) {}
  }, 0);
}

/* =========================
   Utils
========================= */
function parseDelimited(text, delimiter = ';') {
  const rows = [];
  let row = [];
  let cur = '';
  let inQuotes = false;

  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    const next = text[i + 1];

    if (ch === '"') {
      if (inQuotes && next === '"') { cur += '"'; i++; }
      else inQuotes = !inQuotes;
      continue;
    }
    if (!inQuotes && ch === delimiter) { row.push(cur); cur = ''; continue; }
    if (!inQuotes && ch === '\n') { row.push(cur); rows.push(row); row = []; cur = ''; continue; }
    cur += ch;
  }
  row.push(cur);
  rows.push(row);

  return rows.filter(r => r.some(cell => String(cell).trim() !== ''));
}

function normCell(x) { return String(x ?? '').trim(); }
function isX(x) {
  const v = normCell(x).toLowerCase();
  return v === 'x' || v === '';
}
const LETTERS = ['a','b','c','d'];

function extractLeadingLetter(text) {
  const s = normCell(text);
  const m = s.match(/^([A-Da-d])\s*[\.\)]\s*/);
  return m ? m[1].toLowerCase() : null;
}
function stripLeadingOption(text) {
  const s = normCell(text);
  return s.replace(/^[A-Da-d]\s*[\.\)]\s*/, '').trim();
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function escapeHtml(str) {
  return String(str ?? '')
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}

function uid() {
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

function screenEl() { return document.getElementById('screen'); }

function scoreOutOf10(correct, total) {
  if (!total) return 0;
  return Math.round((correct / total) * 10 * 100) / 100; // 2 decimales
}

/* =========================
   Preguntas Fallidas (localStorage)
========================= */
const FAILED_QUESTIONS_KEY = 'quiz_failed_questions';

function getQuestionId(question) {
  // Genera un ID √∫nico basado en tema + pregunta
  return `${normCell(question.tema)}|||${normCell(question.pregunta)}`;
}

function getFailedQuestions() {
  try {
    const stored = localStorage.getItem(FAILED_QUESTIONS_KEY);
    if (!stored) return [];
    return JSON.parse(stored);
  } catch (e) {
    return [];
  }
}

function saveFailedQuestion(question) {
  const failed = getFailedQuestions();
  const qId = getQuestionId(question);
  
  // Verificar si ya existe
  if (failed.some(fq => getQuestionId(fq) === qId)) return;
  
  // Guardar la pregunta completa con sus opciones (guardando sourceLetter y text para reconstruir)
  const optionsToSave = question.options.map(opt => ({
    text: opt.text,
    sourceLetter: opt.sourceLetter,
  }));
  
  // Encontrar la opci√≥n correcta por sourceLetter
  const correctOpt = question.options.find(o => o.id === question.correctOptionId);
  const correctSourceLetter = correctOpt ? correctOpt.sourceLetter : null;
  
  failed.push({
    tema: question.tema,
    pregunta: question.pregunta,
    options: optionsToSave,
    correctSourceLetter: correctSourceLetter,
    porque: question.porque,
  });
  
  try {
    localStorage.setItem(FAILED_QUESTIONS_KEY, JSON.stringify(failed));
  } catch (e) {
    console.error('Error guardando pregunta fallida:', e);
  }
}

function removeFailedQuestion(question) {
  const failed = getFailedQuestions();
  const qId = getQuestionId(question);
  
  const filtered = failed.filter(fq => getQuestionId(fq) !== qId);
  
  try {
    localStorage.setItem(FAILED_QUESTIONS_KEY, JSON.stringify(filtered));
  } catch (e) {
    console.error('Error eliminando pregunta fallida:', e);
  }
}

function clearAllFailedQuestions() {
  try {
    localStorage.removeItem(FAILED_QUESTIONS_KEY);
  } catch (e) {
    console.error('Error limpiando preguntas fallidas:', e);
  }
}

function getFailedQuestionsFromStorage() {
  return getFailedQuestions();
}

/* =========================
   CSV -> Questions
   - La letra A/B/C/D SOLO interno
   - En pantalla NO se muestra
========================= */
function buildQuestions(csvText) {
  csvText = csvText.replace(/^\uFEFF/, '');
  const rows = parseDelimited(csvText, ';');
  if (rows.length < 2) throw new Error('El CSV no tiene filas suficientes.');

  const header = rows[0].map(h => normCell(h));
  const idx = (name) => header.findIndex(h => h.toLowerCase() === name.toLowerCase());

  const iTema = idx('Tema');
  const iPregunta = idx('Pregunta');
  const iR1 = idx('Respuesta 1');
  const iR2 = idx('Respuesta 2');
  const iR3 = idx('Respuesta 3');
  const iR4 = idx('Respuesta 4');
  const iCorrecta = idx('Respuesta correcta');
  const iPorque = idx('Porque');

  const needed = [iTema,iPregunta,iR1,iR2,iR3,iR4,iCorrecta,iPorque];
  if (needed.some(i => i === -1)) throw new Error('Cabecera inv√°lida: faltan columnas esperadas.');

  const questions = [];

  for (let r = 1; r < rows.length; r++) {
    const row = rows[r].slice();
    while (row.length < header.length) row.push('');

    const tema = normCell(row[iTema]);
    const pregunta = normCell(row[iPregunta]);
    if (!pregunta) continue;

    const correctaRaw = normCell(row[iCorrecta]).toLowerCase();
    let correctLetter = LETTERS.includes(correctaRaw) ? correctaRaw : null;

    const porque = normCell(row[iPorque]);
    const rawOpts = [row[iR1], row[iR2], row[iR3], row[iR4]].map(normCell);

    const options = [];
    for (let k = 0; k < 4; k++) {
      if (isX(rawOpts[k])) continue;

      const embedded = extractLeadingLetter(rawOpts[k]);
      const sourceLetter = embedded ?? LETTERS[k];
      const text = stripLeadingOption(rawOpts[k]) || rawOpts[k];

      options.push({
        id: uid(),
        text,
        sourceLetter, // interno
      });
    }

    if (options.length === 1) correctLetter = options[0].sourceLetter;

    let correctOptionId = null;
    if (correctLetter) {
      const found = options.find(o => o.sourceLetter === correctLetter);
      if (found) correctOptionId = found.id;
    }
    if (!correctOptionId && options.length === 1) correctOptionId = options[0].id;

    const shuffledOptions = shuffle(options);

    questions.push({
      tema,
      pregunta,
      options: shuffledOptions,
      correctOptionId,
      porque,
    });
  }

  if (questions.length === 0) throw new Error('No se encontraron preguntas v√°lidas en el CSV.');
  return questions;
}

/* =========================
   Modos
========================= */
function getThemes(allQuestions) {
  const set = new Set();
  for (const q of allQuestions) {
    const t = normCell(q.tema);
    if (t) set.add(t);
  }

  const collator = new Intl.Collator('es', {
    numeric: true,       // <- clave: ordena 2 antes que 10
    sensitivity: 'base'  // ignora may√∫sculas/acentos en la comparaci√≥n
  });

  return Array.from(set).sort((a, b) => collator.compare(a, b));
}

function makeQuizRandom33(allQuestions) {
  return shuffle(allQuestions).slice(0, Math.min(33, allQuestions.length));
}

function makeQuizByThemeAll(allQuestions, theme) {
  const filtered = allQuestions.filter(q => normCell(q.tema) === theme);
  return shuffle(filtered);
}

function makeQuizAll(allQuestions) {
  return shuffle(allQuestions);
}

function makeQuizFailed(allQuestions) {
  const failed = getFailedQuestionsFromStorage();
  if (failed.length === 0) return [];
  
  // Reconstruir las preguntas fallidas con IDs nuevos para las opciones
  const reconstructed = failed.map(fq => {
    const options = fq.options.map(opt => ({
      id: uid(),
      text: opt.text,
      sourceLetter: opt.sourceLetter,
    }));
    
    // Encontrar la opci√≥n correcta por sourceLetter
    const correctOpt = options.find(o => o.sourceLetter === fq.correctSourceLetter);
    const correctOptionId = correctOpt ? correctOpt.id : null;
    
    return {
      tema: fq.tema,
      pregunta: fq.pregunta,
      options: shuffle(options),
      correctOptionId,
      porque: fq.porque,
    };
  });
  
  return shuffle(reconstructed);
}

/* =========================
   UI
========================= */
function renderLoading(msg = 'Cargando‚Ä¶') {
  screenEl().innerHTML = `
    <div class="row between">
      <h1>Quiz de HCN para la inteligencia artificial</h1>
      <span class="badge">Modos: 33 / Tema / Todas</span>
    </div>
    <p class="muted">${escapeHtml(msg)}</p>
  `;
}

function renderError(err) {
  screenEl().innerHTML = `
    <div class="row between">
      <h1>Quiz de HCN para la inteligencia artificial</h1>
      <span class="badge">CSV: <code>preguntas.csv</code></span>
    </div>
    <p><b>No pude cargar el CSV autom√°ticamente.</b></p>
    <p class="muted small">Motivo: ${escapeHtml(err)}</p>
    <div class="divider"></div>
    <p>Plan B (funciona incluso abriendo el HTML con doble clic):</p>
    <div class="btns">
      <input type="file" id="fileInput" accept=".csv,text/csv" />
      <button class="primary" id="btnLoad">Cargar CSV</button>
    </div>
  `;

  document.getElementById('btnLoad').addEventListener('click', async () => {
    const inp = document.getElementById('fileInput');
    if (!inp.files || !inp.files[0]) return;
    const text = await inp.files[0].text();
    const allQuestions = buildQuestions(text);
    startApp(allQuestions);
  });
}

function renderHome(state) {
  const themes = state.themes;
  const failedQuestions = getFailedQuestionsFromStorage();
  const failedCount = failedQuestions.length;

  screenEl().innerHTML = `
    <div class="row between">
      <h1>Quiz de HCN para la inteligencia artificial</h1>
      <span class="badge">Preguntas: ${state.allQuestions.length}</span>
    </div>

    <div class="controls">
      <div class="panel">
        <div class="row between">
          <div class="row"><span class="badge">Modo</span></div>
          <span class="muted small">Se barajan preguntas y opciones</span>
        </div>

        <div class="grid2" style="margin-top:10px;">
          <label class="inline">
            <input type="radio" name="mode" value="random" ${state.mode === 'random' ? 'checked' : ''}>
            <b>Aleatorio (33)</b>
          </label>

          <label class="inline">
            <input type="radio" name="mode" value="all" ${state.mode === 'all' ? 'checked' : ''}>
            <b>Todas (todo el CSV)</b>
          </label>

          <label class="inline">
            <input type="radio" name="mode" value="theme" ${state.mode === 'theme' ? 'checked' : ''}>
            <b>Por tema (todas)</b>
          </label>

          <label class="inline">
            <input type="radio" name="mode" value="failed" ${state.mode === 'failed' ? 'checked' : ''} ${failedCount === 0 ? 'disabled' : ''}>
            <b>Preguntas fallidas (${failedCount})</b>
          </label>
        </div>

        <div id="themePicker" style="margin-top:12px; ${state.mode === 'theme' ? '' : 'display:none;'}">
          <div class="muted small" style="margin-bottom:8px;">Elige tema:</div>
          <select id="themeSelect">
            ${themes.map(t => `<option value="${escapeHtml(t)}" ${t === state.selectedTheme ? 'selected' : ''}>${escapeHtml(t)}</option>`).join('')}
          </select>
        </div>

        <div class="btns">
          <button class="primary" id="btnStart" ${state.mode === 'failed' && failedCount === 0 ? 'disabled' : ''}>Empezar</button>
          <button id="btnReload">Recargar CSV</button>
        </div>

        <div class="divider"></div>
        <div class="panel" style="margin-top:12px;">
          <div class="row between">
            <div class="row"><span class="badge">Descargar preguntas</span></div>
          </div>
          <div class="btns" style="margin-top:10px;">
            <button id="btnDownloadPDF">Descargar PDF</button>
            <button id="btnDownloadCSV">Descargar CSV</button>
          </div>
        </div>

        <div class="divider"></div>
        <div class="panel" style="margin-top:12px;">
          <div class="row between">
            <div class="row"><span class="badge">Preguntas fallidas</span></div>
            <span class="badge">${failedCount} guardadas</span>
          </div>
          ${failedCount > 0 ? `
            <p class="small" style="margin-top:10px;">
              Tienes <b>${failedCount}</b> pregunta${failedCount !== 1 ? 's' : ''} fallida${failedCount !== 1 ? 's' : ''} guardada${failedCount !== 1 ? 's' : ''} en memoria.
              Se eliminar√°n autom√°ticamente cuando las respondas correctamente.
            </p>
            <div class="btns" style="margin-top:10px;">
              <button id="btnViewFailed">Ver preguntas fallidas</button>
              <button id="btnClearFailed">Limpiar todas</button>
            </div>
          ` : `
            <p class="small muted" style="margin-top:10px; margin-bottom:0;">
              No hay preguntas fallidas guardadas. Las preguntas que falles se guardar√°n autom√°ticamente.
            </p>
          `}
        </div>

        <div class="divider"></div>
        <p class="small muted" style="margin:0;">
          Al final ver√°s: <b>nota /10</b>, total, aciertos y fallos.
        </p>
      </div>
    </div>
  `;

  document.querySelectorAll('input[name="mode"]').forEach(el => {
    el.addEventListener('change', (e) => {
      state.mode = e.target.value;
      renderHome(state);
    });
  });

  const themeSelect = document.getElementById('themeSelect');
  if (themeSelect) {
    themeSelect.addEventListener('change', (e) => {
      state.selectedTheme = e.target.value;
    });
  }

  document.getElementById('btnReload').onclick = () => init();

  document.getElementById('btnDownloadPDF').onclick = () => {
    const link = document.createElement('a');
    link.href = 'preguntas.pdf';
    link.download = 'preguntas.pdf';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  document.getElementById('btnDownloadCSV').onclick = () => {
    const link = document.createElement('a');
    link.href = 'preguntas.csv';
    link.download = 'preguntas.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const btnViewFailed = document.getElementById('btnViewFailed');
  if (btnViewFailed) {
    btnViewFailed.onclick = () => renderFailedQuestions(state);
  }

  const btnClearFailed = document.getElementById('btnClearFailed');
  if (btnClearFailed) {
    btnClearFailed.onclick = () => {
      if (confirm('¬øEst√°s seguro de que quieres eliminar todas las preguntas fallidas guardadas?')) {
        clearAllFailedQuestions();
        renderHome(state);
      }
    };
  }

  document.getElementById('btnStart').onclick = () => {
    if (state.mode === 'random') {
      state.quiz = makeQuizRandom33(state.allQuestions);
      state.modeLabel = 'Aleatorio (33)';
    } else if (state.mode === 'all') {
      state.quiz = makeQuizAll(state.allQuestions);
      state.modeLabel = 'Todas (CSV)';
    } else if (state.mode === 'failed') {
      state.quiz = makeQuizFailed(state.allQuestions);
      state.modeLabel = 'Preguntas fallidas';
    } else {
      const theme = state.selectedTheme || state.themes[0];
      state.selectedTheme = theme;
      state.quiz = makeQuizByThemeAll(state.allQuestions, theme);
      state.modeLabel = `Tema: ${theme}`;
    }

    state.index = 0;
    state.answers = Array(state.quiz.length).fill(null);
    state.correctCount = 0;
    state.locked = false;

    if (!state.quiz.length) {
      alert('No hay preguntas para ese modo/tema.');
      return;
    }

    renderQuestion(state);
  };
}

function renderQuestion(state) {
  const q = state.quiz[state.index];
  const progress = `${state.index + 1} / ${state.quiz.length}`;

  const optsHtml = q.options.length
    ? q.options.map((o, idx) => `
        <label class="opt">
          <input type="radio" name="opt" value="${o.id}" ${state.locked ? 'disabled' : ''}>
          <div><div><b>Opci√≥n ${idx + 1}.</b> ${escapeHtml(o.text)}</div></div>
        </label>
      `).join('')
    : `<p class="muted small">Esta pregunta no tiene opciones (o ven√≠an como "x").</p>`;

  const feedbackHtml = state.locked ? buildFeedbackHtml(q, state.answers[state.index]) : '';

  screenEl().innerHTML = `
    <div class="row between">
      <div class="row">
        <h2 style="margin:0;">Pregunta ${progress}</h2>
        <span class="badge">Tema ${escapeHtml(q.tema || '?')}</span>
        <span class="badge">${escapeHtml(state.modeLabel || '')}</span>
      </div>
      <div class="badge">Aciertos: ${state.correctCount}</div>
    </div>

    <p><b>${escapeHtml(q.pregunta)}</b></p>

    <!-- Botones TTS -->
    <div class="btns">
      <button type="button" data-tts="question">Leer pregunta üîä</button>
      ${q.options.length ? `<button type="button" data-tts="options">Leer opciones üîä</button>` : ''}
      <button type="button" data-tts="stop">Parar ‚èπÔ∏è</button>
    </div>

    <div class="opts">${optsHtml}</div>

    ${feedbackHtml}

    <div class="btns">
      <button class="primary" id="btnConfirm" ${state.locked ? 'disabled' : ''}>Confirmar</button>
      <button id="btnNext" ${state.locked ? '' : 'disabled'}>${state.index + 1 === state.quiz.length ? 'Finalizar' : 'Siguiente'}</button>
      <button id="btnQuit">Inicio</button>
    </div>
  `;

  document.getElementById('btnQuit').onclick = () => {
    ttsStop();
    renderHome(state);
  };

  document.getElementById('btnConfirm').onclick = () => {
    const chosen = document.querySelector('input[name="opt"]:checked');
    const selectedId = chosen ? chosen.value : null;

    state.answers[state.index] = selectedId;

    const isCorrect = selectedId && q.correctOptionId && selectedId === q.correctOptionId;
    if (isCorrect) {
      state.correctCount++;
      // Si se responde correctamente, eliminar de preguntas fallidas si estaba guardada
      removeFailedQuestion(q);
    } else {
      // Si se responde incorrectamente, guardar en preguntas fallidas
      saveFailedQuestion(q);
    }

    state.locked = true;
    renderQuestion(state);
  };

  document.getElementById('btnNext').onclick = () => {
    if (!state.locked) return;
    ttsStop();
    if (state.index + 1 >= state.quiz.length) renderEnd(state);
    else { state.index++; state.locked = false; renderQuestion(state); }
  };
}

function buildFeedbackHtml(q, selectedId) {
  const selectedOpt = q.options.find(o => o.id === selectedId);
  const correctOpt = q.options.find(o => o.id === q.correctOptionId);

  const ok = selectedId && q.correctOptionId && selectedId === q.correctOptionId;
  const cls = ok ? 'feedback ok' : 'feedback bad';

  const selectedText = selectedOpt ? selectedOpt.text : '‚Äî';
  const correctText = correctOpt ? correctOpt.text : '‚Äî';

  return `
    <div class="${cls}">
      <div><b>${ok ? '‚úÖ Correcto' : '‚ùå Incorrecto'}</b></div>
      <div class="small">Tu respuesta: <b>${escapeHtml(selectedText)}</b></div>
      <div class="small">Correcta: <b>${escapeHtml(correctText)}</b></div>

      ${q.porque ? `
        <div class="divider"></div>
        <div class="small"><b>Explicaci√≥n:</b> ${escapeHtml(q.porque)}</div>
        <div class="btns">
          <button type="button" data-tts="explanation">Explicar üîä</button>
          <button type="button" data-tts="stop">Parar ‚èπÔ∏è</button>
        </div>
      ` : ''}
    </div>
  `;
}

function renderFailedQuestions(state) {
  const failed = getFailedQuestionsFromStorage();
  
  if (failed.length === 0) {
    screenEl().innerHTML = `
      <div class="row between">
        <h1>Preguntas Fallidas</h1>
        <button id="btnBackHome">‚Üê Inicio</button>
      </div>
      <p class="muted">No hay preguntas fallidas guardadas.</p>
    `;
    document.getElementById('btnBackHome').onclick = () => renderHome(state);
    return;
  }

  const failedList = failed.map((fq, idx) => {
    const correctOpt = fq.options.find(o => o.sourceLetter === fq.correctSourceLetter);
    const correctText = correctOpt ? correctOpt.text : '‚Äî';
    
    return `
      <div class="review-item">
        <div class="row between">
          <div class="row">
            <b>${idx + 1}.</b>
            <span class="badge">Tema ${escapeHtml(fq.tema || '?')}</span>
          </div>
        </div>
        <p style="margin:8px 0;"><b>${escapeHtml(fq.pregunta)}</b></p>
        <p class="small" style="margin:6px 0;">Respuesta correcta: <b>${escapeHtml(correctText)}</b></p>
        ${fq.porque ? `<p class="small muted" style="margin:6px 0;"><b>Explicaci√≥n:</b> ${escapeHtml(fq.porque)}</p>` : ''}
      </div>
    `;
  }).join('');

  screenEl().innerHTML = `
    <div class="row between">
      <h1>Preguntas Fallidas</h1>
      <div class="row">
        <span class="badge">${failed.length} pregunta${failed.length !== 1 ? 's' : ''}</span>
        <button id="btnBackHome">‚Üê Inicio</button>
      </div>
    </div>

    <p class="muted">
      Estas preguntas se eliminar√°n autom√°ticamente cuando las respondas correctamente en cualquier test.
    </p>

    <div class="btns">
      <button class="primary" id="btnPracticeFailed">Practicar preguntas fallidas</button>
      <button id="btnClearAllFailed">Limpiar todas</button>
    </div>

    <div class="divider"></div>
    <h2>Lista de preguntas fallidas</h2>
    ${failedList}
  `;

  document.getElementById('btnBackHome').onclick = () => renderHome(state);
  
  document.getElementById('btnPracticeFailed').onclick = () => {
    state.mode = 'failed';
    state.quiz = makeQuizFailed(state.allQuestions);
    state.modeLabel = 'Preguntas fallidas';
    state.index = 0;
    state.answers = Array(state.quiz.length).fill(null);
    state.correctCount = 0;
    state.locked = false;
    renderQuestion(state);
  };

  document.getElementById('btnClearAllFailed').onclick = () => {
    if (confirm('¬øEst√°s seguro de que quieres eliminar todas las preguntas fallidas guardadas?')) {
      clearAllFailedQuestions();
      renderFailedQuestions(state);
    }
  };
}

function renderEnd(state) {
  ttsStop();

  const total = state.quiz.length;
  const correct = state.correctCount;
  const wrong = total - correct;
  const nota = scoreOutOf10(correct, total);

  const review = state.quiz.map((q, i) => {
    const selId = state.answers[i];
    const selOpt = q.options.find(o => o.id === selId);
    const correctOpt = q.options.find(o => o.id === q.correctOptionId);
    const ok = selId && q.correctOptionId && selId === q.correctOptionId;

    return `
      <div class="review-item">
        <div class="row between">
          <div class="row">
            <b>${i+1}.</b>
            <span class="badge">Tema ${escapeHtml(q.tema || '?')}</span>
          </div>
          <div class="badge">${ok ? '‚úÖ' : '‚ùå'}</div>
        </div>
        <p style="margin:8px 0;"><b>${escapeHtml(q.pregunta)}</b></p>
        <p class="small" style="margin:6px 0;">Tu respuesta: <b>${escapeHtml(selOpt ? selOpt.text : '‚Äî')}</b></p>
        <p class="small" style="margin:6px 0;">Correcta: <b>${escapeHtml(correctOpt ? correctOpt.text : '‚Äî')}</b></p>
        ${q.porque ? `<p class="small muted" style="margin:6px 0;"><b>Explicaci√≥n:</b> ${escapeHtml(q.porque)}</p>` : ''}
      </div>
    `;
  }).join('');

  screenEl().innerHTML = `
    <div class="row between">
      <h1>Resultado</h1>
      <span class="badge">Nota: ${nota} / 10</span>
    </div>

    <div class="row" style="margin-top:8px;">
      <span class="badge">Modo: ${escapeHtml(state.modeLabel || '')}</span>
      <span class="badge">Total: ${total}</span>
      <span class="badge">Aciertos: ${correct}</span>
      <span class="badge">Fallos: ${wrong}</span>
    </div>

    <p class="muted">Puedes reiniciar manteniendo el modo, o volver a inicio para cambiarlo.</p>

    <div class="btns">
      <button class="primary" id="btnRestart">Reiniciar (mismo modo)</button>
      <button id="btnHome">Inicio</button>
    </div>

    <div class="divider"></div>
    <h2>Repaso</h2>
    ${review}
  `;

  document.getElementById('btnRestart').onclick = () => {
    if (state.mode === 'random') {
      state.quiz = makeQuizRandom33(state.allQuestions);
      state.modeLabel = 'Aleatorio (33)';
    } else if (state.mode === 'all') {
      state.quiz = makeQuizAll(state.allQuestions);
      state.modeLabel = 'Todas (CSV)';
    } else if (state.mode === 'failed') {
      state.quiz = makeQuizFailed(state.allQuestions);
      state.modeLabel = 'Preguntas fallidas';
    } else {
      state.quiz = makeQuizByThemeAll(state.allQuestions, state.selectedTheme);
      state.modeLabel = `Tema: ${state.selectedTheme}`;
    }

    state.index = 0;
    state.answers = Array(state.quiz.length).fill(null);
    state.correctCount = 0;
    state.locked = false;
    renderQuestion(state);
  };

  document.getElementById('btnHome').onclick = () => renderHome(state);
}

/* =========================
   Event delegation para TTS
   (m√°s robusto que onclick inline)
========================= */
document.addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-tts]');
  if (!btn) return;

  const action = btn.getAttribute('data-tts');
  const state = window.__appState;
  const q = state?.quiz?.[state?.index];

  if (action === 'stop') {
    ttsStop();
    return;
  }
  if (!q) return;

  if (action === 'question') {
    ttsSpeak(q.pregunta);
  } else if (action === 'options') {
    const text = (q.options || [])
      .map((o, i) => `Opci√≥n ${i + 1}. ${o.text}`)
      .join('. ');
    ttsSpeak(text);
  } else if (action === 'explanation') {
    ttsSpeak(q.porque || '');
  }
});

/* =========================
   Boot
========================= */
function startApp(allQuestions) {
  const themes = getThemes(allQuestions);

  const state = {
    allQuestions,
    themes,
    mode: 'random', // random | theme | all
    selectedTheme: themes[0] || '',
    modeLabel: 'Aleatorio (33)',

    quiz: [],
    index: 0,
    locked: false,
    answers: [],
    correctCount: 0,
  };

  // Estado accesible al handler de eventos
  window.__appState = state;

  renderHome(state);
}

async function init() {
  renderLoading('Intentando cargar "preguntas.csv" desde la misma carpeta‚Ä¶');
  try {
    const resp = await fetch('preguntas.csv', { cache: 'no-store' });
    if (!resp.ok) throw new Error(`HTTP ${resp.status} al cargar preguntas.csv`);
    const text = await resp.text();
    const allQuestions = buildQuestions(text);
    startApp(allQuestions);
  } catch (e) {
    renderError(e?.message || String(e));
  }
}

init();
</script>
</body>
</html>
